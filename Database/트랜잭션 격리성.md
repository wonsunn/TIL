# 트랜잭션 격리성

`격리성(Isolation): 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없다.`
하지만 막연하게 접근할 수 없다라기 보다는 일반적으로 접근 레벨이 존재하며 DB에 따라 설정 가능하다. 이런 격리성은 강하게 또는 약하게 처리할 수 있다.

## 격리성으로 인해 나타날 수 있는 문제점

### 오손 읽기(Dirty Read)

- 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것.
- 작업 중인 다른 트랜잭션 2가 Rollback한 경우, 트랜잭션 1은 무효가 된 데이터를 읽게 되어 잘못된 결과를 도출한다.
  ![image](https://user-images.githubusercontent.com/47625368/122663988-78385c00-d1d9-11eb-932a-224074f629e7.png)
- 이렇게 트랜잭션 2가 Rollback함으로써 **무효 처리된 데이터를 읽게 되어 발생하는 문제**를 Dirty Read라 한다.

### 반복불가능 읽기(Non-Repeatable Read)

- 한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상.
- 즉, 한 트랜잭션이 **읽기 작업을 다시 반복할 경우 이전의 결과와 다른 결과가 나오는 문제**를 말한다.
  ![image](https://user-images.githubusercontent.com/47625368/122664065-fac11b80-d1d9-11eb-9a2d-938544a08ad9.png)
- 이렇게 같은 값을 트랜잭션 2가 갱신(Update)하여 값이 처음과 달라지는 것을 알 수 있다.

### 유령데이터 읽기(Phantom Read)

- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상.
- 즉, 한 트랜잭션이 **읽기 작업을 다시 반복할 때 이전에는 없던 데이터가 나타나는 문제**를 말한다.
  ![image](https://user-images.githubusercontent.com/47625368/122664164-96eb2280-d1da-11eb-92a0-62fc6630bec0.png)
- 이렇게 트랜잭션 2가 새로 데이터를 삽입(Insert)하여 T1 입장에서 이전에는 없던 데이터가 읽히는 것을 알 수 있다.
- **Non-Repeatable Read는 보통 1개의 Row의 데이터 값이 변경**되는 것이며, **Phantom Read는 다건을 요청할 때 주로 발생**한다.

## 격리성 수준(Transaction Isolation Level)

`트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하기 위해 DBMS가 제공하는 명령어`
![image](https://user-images.githubusercontent.com/47625368/122664898-14189680-d1df-11eb-8070-09b1d0fd9c6d.png)

### READ UNCOMMITTED

- 트랜잭션에서 처리 중인 **아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용**한다.
- 고립 수준이 Level 0의 가장 낮은 명령어로, **자신의 데이터에 아무런 공유락을 걸지 않는다.**
- 반면, 배타락은 데이터의 갱신손실 문제 때문에 걸어줘야 한다.
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능하다.
- 어떤 사용자 A가 데이터를 변경하는 동안, 사용자 B는 변경이 완료되지 않은 데이터(Dirty Data)를 읽을 수 있다는 것.

### READ COMMITTED

- 트랜잭션이 **커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용**한다.
  - Dirty Read의 발생을 막아준다.
  - 커밋되지 않은 데이터에 대해서는 실제 DB 데이터가 아닌 Undo 로그에 있는 이전 데이터를 가져온다.
- 고립 수준이 Level 1인 명령어로, **자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에 해지 가능**하다.
- Non-Repeatable Read, Phantom Read 발생 가능하다.
- 어떤 사용자 A가 데이터를 변경하는 동안에 다른 사용자는 해당 데이터에 접근할 수 없다.

### REPEATABLE READ

- 트랜잭션 내에 삭제, 변경에 대해 Undo 로그에 넣어두고 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo 로그에 있는 백업 데이터를 읽게 한다.
  - Non-Repeatable Read의 발생을 막아준다.
  - 트랜잭션 중 값의 변경에 대해 일정한 값으로 처리할 수 있다.
- 고립 수준이 Level 2인 명령어로, **자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료될 때까지 유지**하여 다른 트랜잭션이 자신의 데이터를 갱신(Update)할 수 없도록 한다.
  - 이에 따라 다른 격리 수준에 비해 데이터의 동시성이 낮아 특별한 상황 아니라면 사용하지 않는 것을 권장한다.
- 예를 들어, `SELECT number FROM A WHERE number BETWEEN 1 and 10`을 수행할 때, number가 2인 행에 대한 갱신은 불가능하지만 나머지 범위에 대해 새로운 행을 삽입하는 것은 가능하다.
  - Phantom Read 여전히 발생 가능하다.

### SERIALIZABLE

- 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지 않도록 하는 설정.
- 고립 수준이 Level 3의 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.
- **데이터 집합에 범위를 지어 락을 걸 수 있기 때문에** 다른 사용자가 해당 데이터에 접근할 때 트랜잭션을 완벽하게 분리할 수 있다.
  - 가장 제한이 심하고 동시성도 가장 낮다.

### 참고자료

- https://sabarada.tistory.com/117
- https://mangkyu.tistory.com/30?category=761304
