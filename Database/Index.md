# Index

## 인덱스(Index)란

- 인덱스란 **추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 높이기 위한 자료구조**이다.
- 책에서 원하는 내용을 찾을 때, 책의 모든 페이지를 찾아 보는 것 대신 책의 맨 앞에 색인을 추가하는 것과 같은 개념이다.
- 데이터베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리므로, **데이터와 데이터의 위치를 담은 자료구조를 생성하여 빠르게 조회**할 수 있도록 한다.
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만, 새로운 값을 추가/수정/삭제하는 경우에는 실행 속도가 느려진다.
- 즉, **데이터의 저장 성능을 희생하고 데이터의 읽기 속도를 높이는 기능**이다.

## 인덱스(Index)의 장단점

### 장점

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킨다.
- 테이블 행의 고유성을 강화시킨다.
- 테이블의 기본 키는 자동으로 인덱스가 된다.

### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

#### 단점3 추가 설명

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면, **인덱스의 크기가 비대해져서 성능이 오히려 저하**되는 역효과가 발생할 수 있다. DELETE와 UPDATE 연산 시, 기존의 인덱스를 삭제하지 않고 '사용하지 않음'이라는 추가 처리를 해준다. 만약 어떤 테이블에 DELETE와 UPDATE 작업이 빈번하게 발생된다면 실제 데이터는 10만 건이지만 인덱스는 100만 건이 넘어가, 성능이 떨어질 것이다.

## 인덱스(Index)를 사용하면 좋은 경우

1. 규모가 작지 않은 테이블
2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
3. JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
4. 데이터의 중복도가 낮은 컬럼(유일한 값이 많은 컬럼, Cardinality가 높은 컬럼)

## 인덱스(Index)의 자료구조

### 해시 테이블(Hash Table)

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 **빠른 데이터 검색이 필요할 때 유용**하다. Key 값을 이용해 고유한 index를 생성하여, 그 index에 저장된 값을 꺼내오는 구조이다.

해시 테이블 기반의 인덱스는 Key를 컬럼 값(데이터), Value를 데이터의 위치로 사용하여 컬럼 값으로 생성된 해시를 통해 구현되었다.

해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.

하지만 해시 테이블이 사용되는 경우는 제한적이다. 왜냐하면 해시는 등호(=) 연산에만 특화됐기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는 특성을 가졌기 때문에, **부등호 연산(>,<)을 자주 사용하거나 특정 문자로 시작하는 값으로 검색(like)하는 연산에는 해시 테이블이 적합하지 않다.**

이러한 이유로 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용된다.

### B+Tree

B+Tree는 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. 즉, 모든 노드에 데이터를 저장했던 B-Tree와 다른 특성을 가진다.

- 리프 노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(key)만을 갖는다.
- 리프 노드들은 LinkedList로 연결돼 있다.
- 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 그래서 **B-Tree의 리프 노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화**했다.(리프노드까지 가지 않아도 탐색을 완료할 수 있는 B-Tree에 비해 무조건 리프노드까지 가야한다는 단점은 존재) 즉, **수직적 탐색과 수평적 탐색이 공존**하는 구조이다.

B+Tree의 시간복잡도는 O(logn)을 갖지만, 해시 테이블보다 인덱싱에 더욱 적합한 자료구조이다.

## 인덱스(Index)의 종류

### 키에 따른 분류

- Primary Index : 기본키를 포함하는 인덱스(키의 순서가 레코드의 순서를 결정 짓는다)
- Secondary Index : Primary Index 이외의 인덱스(키의 순서가 레코드의 순서를 의미하지는 않는다)

### 파일 조직에 따른 분류

- Clustered Index
  - 여러 개를 하나로 묶는다는 클러스터를 기반으로, 인덱스에서의 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현된다.
  - 이는 주로 비슷한 값들은 동시에 조회하는 경우가 많다는 점에서 착안된 것으로, 비슷한 값들은 **물리적으로 인접한 장소에 저장되어 있는 데이터들**을 말한다.
  - 테이블의 Primary Key에 대해서만 적용된다. 즉, **Primary Key 값에 의해 레코드의 저장 위치가 결정**되고, 물리적으로 정렬되어 있다.
  - 이에 따라 검색 속도가 상대적으로 빠르지만, Primary Key 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 하기 때문에 신중하게 사용할 필요가 있다.
  - 테이블당 한 개만 생성할 수 있다.
  - 인덱스 자체의 리프 페이지가 곧 데이터가 담긴 페이지. 즉, **인덱스 자체에 데이터가 포함**되어 있다.
- Non-Clustered Index
  - 테이블당 여러 개를 생성할 수 있다. 하지만, 남용할 경우 성능이 떨어질 수 있다.
  - 데이터는 그대로 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
  - 인덱스 페이지에 데이터 위치를 가리키는 포인터를 생성한다.
  - 이에 따라 Clustered Index보다 검색 속도는 느리지만, 데이터의 입력/수정/삭제는 더 빠르다.

### 참고자료

- https://mangkyu.tistory.com/96?category=761304
- https://k39335.tistory.com/26
- https://lalwr.blogspot.com/2016/02/db-index.html
- https://brunch.co.kr/@skeks463/25
- https://mongyang.tistory.com/75
