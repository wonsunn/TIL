# 고급 매핑

## 상속관계 매핑

- 객체는 상속관계가 존재하지만, 관계형 DB는 존재하지 않는다.
- 슈퍼타입과 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.
- 상속관계 매핑이라는 것은 **객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑**하는 것이다.
  ![image](https://user-images.githubusercontent.com/47625368/123512376-06bd4980-d6c2-11eb-9eb0-939be54dc8bc.png)

### 슈퍼타입 서브타입 논리 모델 -> 물리 모델 구현 방법

DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법에는 3가지가 있다.

JPA가 이 3가지 방식과 매핑하려면

- `@Inheritance(strategy = InheritanceType.XXX)`의 strategy를 설정해주면 된다.
  - default는 SINGLE_TABLE(단일 테이블 전략)이다.
  - InheritanceType 종류
    - JOINED
    - SINGLE_TABLE
    - TABLE_PER_CLASS
- `@DiscriminatorColumn(name = "DTYPE)`
  - 부모 클래스에 선언한다.
  - 하위 클래스를 구분하는 용도의 칼럼이다.
  - 관례는 default = DTYPE
- `@DiscriminatorValue("XXX")`
  - 하위 클래스에 선언한다.
  - 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정한다.
  - 어노테이션을 선언하지 않을 경우 기본값으로 클래스 이름이 들어간다.

코드로 알아보면,

- Item

  ```java
  @Entity
  @Inheritance(strategy = InheritanceType.XXX) // 상속 구현 전략 선택
  public class Item {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      private String name;
      private int price;
  }
  ```

- Album

  ```java
  @Entity
  public class Album extends Item {

      private String artist;
  }
  ```

- Movie

  ```java
  @Entity
  public class Movie extends Item {

      private String director;
      private String actor;
  }
  ```

- Book

  ```java
  @Entity
  public class Book extends Item {

      private String author;
      private String isbn;
  }
  ```

### 1. 각각의 테이블로 변환하는 조인 전략(JOINED)

![image](https://user-images.githubusercontent.com/47625368/123512609-58b29f00-d6c3-11eb-9e95-18a2584a59cd.png)

- 가장 정규화된 방법으로 구현하는 방식이다.
- NAME, PRICE가 ITEM 테이블에만 저장되고, ALBUM, MOVIE, BOOK이 각자의 데이터만 저장한다.
- 부모 클래스인 Item 엔티티에 @Inheritance(strategy = InheritanceType.JOINED) 전략

  - 하이버네이트의 조인 전략에서는 **@DiscriminatorColumn을 선언하지 않으면 DTYPE 컬럼이 생성되지 않는다.**

    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.JOINED)
    @DiscriminatorColumn // 하위 테이블의 구분 컬럼 생성(default = DTYPE)
    public class Item {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
        private int price;
    }
    ```

- 실제 실행된 DDL
  - 테이블 4개 생성
  - 하위 테이블에 외래키 제약조건 생성. 하위 테이블 입장에서는 ITEM_ID가 PK이면서 FK로 잡아야 한다.
    ```sql
    Hibernate:
        create table Album (
          artist varchar(255),
            id bigint not null,
            primary key (id)
        )
    Hibernate:
        create table Book (
          author varchar(255),
            isbn varchar(255),
            id bigint not null,
            primary key (id)
        )
    Hibernate:
        create table Item (
          DTYPE varchar(31) not null,
            id bigint generated by default as identity,
            name varchar(255),
            price integer not null,
            primary key (id)
        )
    Hibernate:
        create table Movie (
          actor varchar(255),
            director varchar(255),
            id bigint not null,
            primary key (id)
        )


    Hibernate:
        alter table Album
          add constraint FKcve1ph6vw9ihye8rbk26h5jm9
          foreign key (id)
          references Item
    Hibernate:
        alter table Book
          add constraint FKbwwc3a7ch631uyv1b5o9tvysi
          foreign key (id)
          references Item
    Hibernate:
        alter table Movie
          add constraint FK5sq6d5agrc34ithpdfs0umo9g
          foreign key (id)
          references Item
    ```
- Movie 객체를 저장하면?

  - Insert 쿼리가 Item 테이블, Movie 테이블에 두 번 나간다.
  - DTYPE에 클래스 이름이 default로 저장된다.

    ```java
    Movie movie = new Movie();
    movie.setDirector("감독A");
    movie.setActor("배우B");
    movie.setName("분노의질주");
    movie.setPrice(35000);

    em.persist(movie);

    tx.commit();
    ```

    ```sql
    Hibernate:
    /* insert advancedmapping.Movie
        */ insert
        into
            Item
            (id, name, price, DTYPE)
        values
            (null, ?, ?, 'Movie')
    Hibernate:
    /* insert advancedmapping.Movie
        */ insert
        into
            Movie
            (actor, director, id)
        values
            (?, ?, ?)
    ```

- Movie 객체를 조회하면?

  - flush(), clear()를 해주면, DB에 insert 쿼리를 날리고, 1차 캐시를 지우므로 find에서 SELECT 쿼리가 나간다.
  - Item과 inner join을 통해 결과를 조회한다.

    ```java
    Movie movie = new Movie();
    movie.setDirector("감독A");
    movie.setActor("배우B");
    movie.setName("분노의질주");
    movie.setPrice(35000);

    em.persist(movie);

    em.flush();
    em.clear();  //DB에 insert쿼리 날리고, 1차 캐시 지우므로 find에서 SELECT 쿼리가 나간다.

    em.find(Movie.class, movie.getId());

    tx.commit();
    ```

    ```sql
    Hibernate:
    select
        movie0_.id as id2_2_0_,
        movie0_1_.name as name3_2_0_,
        movie0_1_.price as price4_2_0_,
        movie0_.actor as actor1_3_0_,
        movie0_.director as director2_3_0_
    from
        Movie movie0_
    inner join
        Item movie0_1_
            on movie0_.id=movie0_1_.id
    where
        movie0_.id=?
    ```

### 2. 통합 테이블로 변환하는 단일 테이블 전략(SINGLE_TABLE)

![image](https://user-images.githubusercontent.com/47625368/123512807-7d5b4680-d6c4-11eb-946d-b09c1ecbcb07.png)

- 서비스 규모가 크지 않고, 굳이 조인 전략을 선택해서 복잡하게 할 필요가 없다고 판단될 때 주로 사용한다.
- 한 테이블에 다 저장하고, DTYPE으로 구분하는 단일 테이블 전략을 선택할 수 있다.
- INSERT 쿼리도 한 번, SELECT 쿼리도 한 번 수행된다.
- 조인할 필요가 없고 성능이 좋다.
- 단일 테이블 적용

  - strategy를 SINGLE_TABLE로 변경하면 된다.
  - 단일 테이블 전략에서는 @DiscriminatorColumn을 선언해 주지 않아도, 기본으로 DTYPE 컬럼이 생성된다.
  - 한 테이블에 모든 컬럼을 저장하기 때문에 **DTYPE 없이는 테이블을 판단할 수 없다.**

    ```java
    @Entity
    @DiscriminatorColumn
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    public class Item {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
        private int price;
    }
    ```

  - 실행된 DDL
    - 통합 테이블이 하나 생성된다.
      ```sql
      Hibernate:
          create table Item (
            DTYPE varchar(31) not null,
              id bigint generated by default as identity,
              name varchar(255),
              price integer not null,
              artist varchar(255),
              author varchar(255),
              isbn varchar(255),
              actor varchar(255),
              director varchar(255),
              primary key (id)
          )
      ```
  - 저장, 조회 예제롤 그대로 돌려본다면?
    - Item 테이블을 조회. 조인하지 않고 DTYPE을 검색 조건으로 추가해서 Movie를 조회한다.
      ```sql
      Hibernate:
      select
          movie0_.id as id2_0_0_,
          movie0_.name as name3_0_0_,
          movie0_.price as price4_0_0_,
          movie0_.actor as actor8_0_0_,
          movie0_.director as director9_0_0_
      from
          Item movie0_
      where
          movie0_.id=?
          and movie0_.DTYPE='Movie'
      ```

### 3. 서브타입 테이블로 변환하는 구현 클래스마다 테이블을 생성하는 전략(TABLE_PER_CLASS)

![image](https://user-images.githubusercontent.com/47625368/123512972-623d0680-d6c5-11eb-9023-c3aa06f20ed9.png)

- 조인 전략과 유사하지만, 슈퍼 타입의 컬럼들을 서브 타입으로 내린다는 차이가 있다.
  - NAME, PRICE 컬럼들이 중복되도록 허용하는 전략
- 구현 클래스마다 테이블 생성 전략 적용

  - @Id 생성 전략 GenerationType.AUTO를 사용할 경우 strategy를 TABLE_PER_CLASS로 변경한다.
  - 이때, ITEM 엔티티는 실제 생성되는 테이블이 아니므로 abstract 클래스여아 하고, @DiscriminatorColumn도 필요없게 된다.
  - Item 엔티티 설정

    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
    public abstract class Item {

        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private Long id;

        private String name;
        private int price;
    }
    ```

  - 생성된 DDL
    - 하위 테이블 3개만 생성된다.
      ```sql
      Hibernate:
          create table Album (
            id bigint not null,
              name varchar(255),
              price integer not null,
              artist varchar(255),
              primary key (id)
          )
      Hibernate:
          create table Book (
            id bigint not null,
              name varchar(255),
              price integer not null,
              author varchar(255),
              isbn varchar(255),
              primary key (id)
          )
      Hibernate:
          create table Movie (
            id bigint not null,
              name varchar(255),
              price integer not null,
              actor varchar(255),
              director varchar(255),
              primary key (id)
          )
      ```
  - Movie 저장, 조회 그대로 실행하면?
    - Movie 테이블에서 insert, select
      ```sql
      Hibernate:
      /* insert advancedmapping.Movie
          */ insert
          into
              Movie
              (name, price, actor, director, id)
          values
              (?, ?, ?, ?, ?)
      Hibernate:
          select
              movie0_.id as id1_2_0_,
              movie0_.name as name2_2_0_,
              movie0_.price as price3_2_0_,
              movie0_.actor as actor1_3_0_,
              movie0_.director as director2_3_0_
          from
              Movie movie0_
          where
          movie0_.id=?
      ```
  - 문제점

    - 객체지향 프로그래밍에서는 MOVIE, ALBUM, BOOK 객체를 ITEM 타입으로 조회할 수 있다.

      ```java
      Movie movie = new Movie();
      movie.setDirector("감독A");
      movie.setActor("배우B");
      movie.setName("분노의질주");
      movie.setPrice(35000);

      em.persist(movie);

      em.flush();
      em.clear();

      em.find(Item.class, movie.getId());

      tx.commit();
      ```

    - 실행된 sql
      - union all로 전체 하위 테이블을 모두 찾는다.
      - 조회는 굉장히 비효율적
      ```sql
      Hibernate:
            select
                item0_.id as id1_2_0_,
                item0_.name as name2_2_0_,
                item0_.price as price3_2_0_,
                item0_.artist as artist1_0_0_,
                item0_.author as author1_1_0_,
                item0_.isbn as isbn2_1_0_,
                item0_.actor as actor1_3_0_,
                item0_.director as director2_3_0_,
                item0_.clazz_ as clazz_0_
            from
                ( select
                    id,
                    name,
                    price,
                    artist,
                    null as author,
                    null as isbn,
                    null as actor,
                    null as director,
                    1 as clazz_
                from
                    Album
                union
                all select
                    id,
                    name,
                    price,
                    null as artist,
                    author,
                    isbn,
                    null as actor,
                    null as director,
                    2 as clazz_
                from
                    Book
                union
                all select
                    id,
                    name,
                    price,
                    null as artist,
                    null as author,
                    null as isbn,
                    actor,
                    director,
                    3 as clazz_
                from
                    Movie
            ) item0_
        where
            item0_.id=?
      ```

### 상속관계 매핑 정리

#### 조인 전략

- 장점
  - 테이블이 정규화가 되어있다.
  - 외래키 참조 무결성 제약조건 활용 가능하다.
  - 저장공간 효율화
    - 테이블 정규화로 저장공간이 딱 필요한 만큼 소비된다.
- 단점
  - 조회시 조인을 많이 사용하기 때문에 조회 쿼리가 다소 복잡하다.
  - 데이터 저장시 INSERT 쿼리가 상위, 하위 테이블에 두번 호출한다.
- 정리
  - 성능 저하라고 되어있지만, 실제로는 영향이 크지 않다.
  - 오히려 저장공간이 효율화되기 때문에 장점이 크다.
  - 기본적으로 조인 전략이 정석이라고 보면 된다. 객체랑도 잘 맞고, 정규화도 되어 설계가 깔끔하다.

#### 단일 테이블 전략

- 장점
  - 조인이 필요 없으므로 일반적인 조회 성능이 빠르다.
  - 조회 쿼리가 단순하다.
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 NULL을 허용해야 한다.
  - 단일 테이블에 모든 것을 저장하기 때문에 테이블이 커질 수 있다.
  - 상황에 따라서는 조인 전략보다 성능이 오히려 느려질 수 있다.

#### 구현 클래스마다 테이블 전략

- 결론부터 말하면
  - 이 전략은 안 쓰는게 낫다.
  - ORM을 하다보면 데이터 쪽과 객체 쪽에서 trade-off할 때가 있는데, 이 전략은 둘 다 추천하지 않는 방식.
- 장점
  - 서브 타입을 명확하게 구분해서 처리할 때 효과적이다.
  - NOT NULL 제약조건을 사용할 수 있다.
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느리다(UNION 사용)
  - 자식 테이블을 통합해서 쿼리하기 어렵다.

## @MappedSuperclass

- **객체 입장에서 공통 매핑 정보가 필요**할 때 사용한다.
- id, name은 객체 입장에서 볼 때 계속 나온다.
- 이렇게 공통 매핑 정보가 필요할 때, \**부모 클래스에 선언하고 속성만 상속받아서 사용*8하고 싶을 때 @MappedSuperclass를 사용한다.
- DB 테이블과는 상관없다. 객체의 입장이다.
  ![image](https://user-images.githubusercontent.com/47625368/123513493-82ba9000-d6c8-11eb-866f-220b56104ff9.png)

#### 코드로 이해

생성자, 생성시간, 수정자, 수정시간을 모든 엔티티에서 공통으로 가져가야 하는 상황에서 아래와 같이 BaseEntity를 정의해서 활용할 수 있다.

- BaseEntity.java

  - 매핑 정보만 상속받는 Superclass라는 의미의 @MappedSuperclass 어노테이션 선언

    ```java
    @Getter
    @Setter
    @MappedSuperclass
    public abstract class BaseEntity {

        private String createdBy;

        private LocalDateTime createdDate;

        private String lastModifiedBy;

        private LocalDateTime lastModifiedDate;
    }
    ```

- Member.java, Team.java
  - BaseEntity 상속
    ```java
    @Entity
    public class Member extends BaseEntity {
        ...
    }
    ```
    ```java
    @Entity
    public class Team extends BaseEntity {
        ...
    }
    ```
- 실행된 DDL
  - BaseEntity에 선언된 컬럼들이 생성된다.
    ```sql
    Hibernate:
        create table Member (
          id bigint generated by default as identity,
            createdBy varchar(255),
            createdDate timestamp,
            lastModifiedBy varchar(255),
            lastModifiedDate timestamp,
            age integer,
            description clob,
            roleType varchar(255),
            name varchar(255),
            locker_id bigint,
            team_id bigint,
            primary key (id)
        )
    Hibernate:
        create table Team (
          id bigint generated by default as identity,
            createdBy varchar(255),
            createdDate timestamp,
            lastModifiedBy varchar(255),
            lastModifiedDate timestamp,
            name varchar(255),
            primary key (id)
        )
    ...
    ```

### 정리

- 상속관계 매핑이 아니다.
- @MappedSuperclass가 선언되어 있는 클래스는 엔티티가 아니다. 당연히 테이블과 매핑도 안된다.
- 단순히 부모 클래스를 상속받는 **자식 클래스에게 매핑 정보만 제공**한다.
- 조회, 검색이 불가능하다. (em.find(BaseEntity) 불가능)
- 직접 생성해서 사용할 일이 없으므로 **추상 클래스로 만드는 것을 권장**한다.
- 테이블과 관계없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 한다.
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.
- 참고
  - **JPA에서 @Entity 클래스는 @Entity나 @MappedSuperclass로 지정한 클래스만 상속**할 수 있다.
