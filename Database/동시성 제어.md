# 동시성 제어

## 동시성 제어란

- 다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근 및 실행 순서를 제어하는 것.
- 서로 다른 2개 이상의 트랜잭션이 모두 쓰기(write) 작업을 수행할 때 서로 간의 간섭을 통해 여러 문제가 발생할 수 있다.

### 갱신 손실(Lost Update)

- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화되는 현상.
- 두 개의 트랜잭션이 하나의 데이터를 동시에 갱신할 때 발생한다.
  ![image](https://user-images.githubusercontent.com/47625368/122633631-840e1a80-d114-11eb-803a-5f56d7b839c7.png)
  트랜잭션T1이 갱신한 내용을 커밋하기 전의 값을 트랜잭션T2가 다르게 갱신하여 T1의 값이 무효화된다.

### 모순성(Inconsistency)

- 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 **어떤 것은 갱신되기 전의 값을 읽고, 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황**.
  ![image](https://user-images.githubusercontent.com/47625368/122633716-ef57ec80-d114-11eb-8b5a-b6a445387fb0.png)

### 연쇄 복귀(Cascading Rollback)

- 두 트랜잭션이 동일한 데이터 내용에 접근할 때 발생한다.
- 특정 트랜잭션이 이전 상태로 복귀(rollback)하려고 할 때, 아무 문제 없는 다른 트랜잭션까지 연달아 복귀해야 하는 문제.
- 이때 다른 트랜잭션이 이미 완료된 상태라면 복귀할 수 없는 문제가 발생한다.
  ![image](https://user-images.githubusercontent.com/47625368/122633816-6e4d2500-d115-11eb-8dd5-a79f3ba19d55.png)

## 이러한 문제를 어떻게 해결할 수 있을까

`직렬 스케줄 또는 직렬 가능한 스케줄로 만들어야 한다.`

- 직렬 스케줄은 끼어들기를 허용하지 않고 순차적으로 실행하기 때문에 다중 프로그래밍 환경에서 최적의 방법이라고 볼 수 없다.
- 그렇다면, 동시성(병행 수행)을 최대하 보장하면서 직렬 스케줄과 동일한 결과를 얻을 수 있는 **직렬 가능한 스케줄**로 만드는 것이 가장 좋은 방법이다.
- 이를 위해 **잠금(Locking) 기법**을 사용한다.

## 잠금(Locking)

`트랜잭션의 실행 순서를 강제로 제어하여 직렬 가능한 스케줄이 되도록 보장하는 방법`

- 하나의 트랜잭션이 데이터 항목에 대해 잠금(lock)을 설정하면, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 **독점적으로 사용**할 수 있다.

### 잠금 연산의 종류

- 공유락(Shared lock:S-lock)
  - 공유락을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다.
  - 하나의 데이터 항목에 대해 여러 개의 공유락이 가능하다.
  - 다른 트랜잭션도 읽기 연산(read)만을 실행할 수 있다.
- 배타락(Exclusive lock:X-lock)
  - 배타락을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다.
  - 하나의 데이터 항목에 대해 하나의 배타락만 가능하다.
  - 다른 트랜잭션은 읽기 연산(read)과 쓰기 연산(write) 모두 불가능하다.

### 잠금 단위(Locking Granularity)

- 잠금 단위는 **잠금 대상이 되는 데이터 객체의 크기**를 의미한다.
- 잠금 단위 : 속성(필드) < 튜플(레코드) < 릴레이션(파일) < 데이터베이스 순으로 커진다.
  - 잠금 단위가 클수록 동시성 수준은 낮아지고, 동시성 제어 기법은 간단해진다.
  - 잠금 단위가 작을수록 동시성 수준은 높아지고, 관리는 복잡해진다.
- 잠금 단위를 여러 단계로 정해 놓고 필요에 따라 혼용하는 방식이 많이 사용된다.

### 잠금 한계

- 직렬 가능한 스케줄이 항상 보장되지 않는다. -> **2단계 잠금 규약(2PL)**으로 해결한다.
- 교착 상태(deadlock)가 발생할 수 있다.

### 2단계 잠금 규약(2-Phase Locking protocol:2PL)

`2PL은 잠금을 설정하는 단계와 해제하는 단계로 나누어 실행한다.`

- 확장 단계(growing phase) : 트랜잭션이 lock 연산만 수행할 수 있고, unlock 연산은 수행할 수 없는 단계.
- 축수 단계(shrinking phase) : 트랜잭션이 unlock 연산만 수행할 수 있고, lock 연산은 수행할 수 없는 단계.

하지만, 2PL로도 **교착 상태는 여전히 해결되지 않는다.**
![image](https://user-images.githubusercontent.com/47625368/122634568-d6056f00-d119-11eb-80de-cbe4f8e6cde2.png)
오른쪽 그림이 2PL을 준수하지만 교착상태가 발생한 사례. 이를 해결하기 위해 각 트랜잭션을 시작하기 전에 모든 필요한 잠금을 동시에 설정하는 방법이 있다. 또한, 교착상태 회피 방법이나 탐지 방법을 통해 해결 가능하다.

2PL은 **연쇄 복귀 문제**도 발생할 수 있다.
![image](https://user-images.githubusercontent.com/47625368/122634608-1238cf80-d11a-11eb-9744-65f29f9e5781.png)
이는 **엄격한 2PL**로 해결 가능하다. 엄격한 2PL이란 **모든 X-lock에 대한 unlock 연산을 트랜잭션이 완전히 완료된 후에 실행하는 것**이다. 이렇게 하면 완료되지 않은 트랜잭션에 의해 갱신된 데이터를 다른 트랜잭션이 읽거나 쓸 가능성을 원천적으로 봉쇄할 수 있어 연쇄 복귀 문제를 해결할 수 있다. 현재 대부분의 DBMS에서 엄격한 2PL 규약을 이용하여 동시성 제어를 구현한다.

### 참고자료

- https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a
- https://mangkyu.tistory.com/30?category=761304
